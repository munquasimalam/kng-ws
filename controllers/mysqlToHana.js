var db_query = require('../db/executeQuery');
const config = require('../config/config');
const fs = require('fs');
var mysql = require('mysql');
var hdb = require('hdb');
mysqlCon="";
hanaCon="";
mysqlDatabase="";



const mySQLParams = {
    SMALLINT:/smallint[(]+[0-9]+[)]/g,
    INT:/int[(]+[0-9]+[)]/g,
    UNASIGNED: /unsigned/g,
    TINYTEXT: /tinytext/g,
    BACKTICKS: /`/g,
    AUTO_INCREMENT: /AUTO_INCREMENT/g,
    TABLE: 'TABLE',
    CHARACTER_SET_LATIN1: /CHARACTER SET latin1/g,
    COLLATE: /COLLATE/g,
    LATIN1_BIN: /latin1_bin/g,
    LONGTEXT: /longtext/g,
    MEDIUMTEXT: /mediumtext/g,
    LONGBLOB: /longblob/g,
    DOUBLE: /double/g,
    BIGINTEGER: /bigint[(]+[0-9]+[)]/g,
    DOUBLE: /double/g,
    TINYINTEGER: /tinyint[(]+[0-9]+[)]/g
}

const hanaSQLParams = {
    SMALLINT:'SMALLINT',
    INTEGER:'INTEGER',
    IDENTITY:"GENERATED BY DEFAULT AS IDENTITY",
    VARCHARTEN: "VARCHAR(10)",
    VARCHARMAX: "VARCHAR(5000)",
    VARCHARMEDIUM: "VARCHAR(2500)",
    COLUMN_TABLE: 'COLUMN TABLE',
    BLOB: 'BLOB',
    DECIMAL: 'DECIMAL',
    BIGINT: 'BIGINT',
    TINYINT: 'TinyINT',
    BLANK: '',
}



async function getMysqlConnection(connectionParams,next){
    console.log(connectionParams);
     
    let dbObject = {
        host:connectionParams.idAddress,
        user:connectionParams.name,
        password:connectionParams.password,
        port :connectionParams.port, //port mysql
        database:connectionParams.db
    }

//Mysql  Database connection
mysqlCon = mysql.createConnection(dbObject);
this.mysqlCon=mysqlCon;
console.log("mysqlCon:"+mysqlCon);
mysqlDatabase=await dbConnect(dbObject);
return next(null,mysqlDatabase);

}

function dbConnect(dbObject){
    return new Promise((resolve,reject)=>{
        mysqlCon.connect((err)=>{
            if(err) {
                // console.log(err);
                return reject(err);
            }
            console.log("mysqldb '", dbObject.database, "' Connected.");
            this.mysqlDatabase=dbObject.database;
            console.log("mysqlDatabase:"+mysqlDatabase);
           return  resolve(mysqlDatabase);
        });
    });
}

function getHanaConnection(connectionParams,next){
    let dbObject = {
        host:connectionParams.idAddress,
        user:connectionParams.name,
        password:connectionParams.password,
        port :connectionParams.port, 
        database:connectionParams.db
    }

//SapHana  Database connection
 hanaCon = hdb.createClient(dbObject);
 this.hanaCon=hanaCon;
 console.log("hanaCon:"+hanaCon);
 hanaCon.connect((err) => {
     if (err) {
         console.log("connection lost: ", err);
         return next(err);
     }
     console.log("hanadb '", dbObject.database, "' Connected.");
     return next(null,dbObject.database);
 });

}

function showTableNames(){
    // const query = "select TABLE_NAME from information_schema.tables where table_schema = database() AND TABLE_TYPE != 'VIEW';"
    const query = "SHOW TABLES"
    return new Promise((resolve, reject)=>{
        db_query.query(query,(err,tables)=>{
            if(err) return reject(err.sqlMessage);
            return resolve(tables);
           
        })
    });
}



async function createtables(selectedtableNameObjs,next){
   
    console.log(selectedtableNameObjs);
    // try {
    //       console.log(selectedtableNameObjs);
    // } catch (error) {
    //     console.log(error);
    //     //dbDisconnect();
    //     return;
    //     // LOG ERROR
    // }

     await done(selectedtableNameObjs);
      next(null,"Done");
  
}


function done(selectedtableNameObjs){
    let failCount=0;
    let successCount=0;

    selectedtableNameObjs.forEach(async (tableObj) => {

     // let createStatement = 'CREATE COLUMN TABLE "' + config.db.database + '"."' + table[columnName] + '" (\n',
        let createStatement = 'CREATE COLUMN TABLE "ECLINIC_KNG"."' + tableObj.itemName.toUpperCase() + '" (\n',
        keys = [];
        try {
            //columns = await showTableColumn(table[columnName]);
            columns = await showTableColumn(tableObj["itemName"]);
            console.log("columns:"+columns);
        } catch (error) {
            console.log("error:"+error);
            fs.appendFileSync("./sql/create/ErrorLog_log",new Date()+  error +"\n"); 
              
        }
        if(Array.isArray(columns)){
             console.log(columns);
            columns.forEach(col=>{
                createStatement = createStatement + hanaColumnDefinition(col).trim() + ',\n';
                 console.log(createStatement);
                keys = checkKey(col.Key,col.Field.toUpperCase(),keys);
            });
             console.log(keys);
            if(keys.length)
                createStatement = createStatement + 'PRIMARY KEY ("' + keys.join("\",\"") +'"),\n';
            createStatement = createStatement.substring(0, createStatement.length - 2) + ");\n";
              console.log(createStatement);
            //createFile("D:/alam/SapHana/kng/sql/create/"+ table[columnName]+ ".sql", createStatement);
            hanaCon.exec(createStatement, function (err) {
               
                if (err) {
                 failCount++;
                  fs.appendFileSync("./sql/create/ErrorLog_log",new Date()+ "Fail Count: "+failCount  +  err +"\n"+createStatement+"\n"); 
                  //return console.error('Error123:', err); 
                   console.error('Error123:', err);  
                } else {
                    successCount++;
                    console.log("Table " +tableObj.itemName + "   has been created");
                    fs.appendFileSync("./sql/create/ErrorLog_log","Current Time: "+new Date()+ "Success Count: "+successCount  +  "Table " +tableObj.itemName + "   has been created" +"\n"); 
                
                }
                  
              });
        } 
    });

   
}

function hanaColumnDefinition(colObj){
    // console.log(col.Field.toUpperCase(), hanaColType(col.Type), checkNotNull(col.Null), defaultValue(col.Default));    
    return '"'+ colObj.Field.toUpperCase() +'" ' 
            + hanaColType(colObj.Type) 
            + checkNotNull(colObj.Null) 
            + checkDefaultValue(colObj.Default, colObj.Type) 
            + checkExtra(colObj.Extra); 
}

function checkKey(key, column, keys){
    // console.log(keys, column);
    switch (key) {
        case "PRI":
            keys.push(column.toString());
            break;
        default:
            break;
    }
    // console.log(keys, column);
    return keys;
}

function checkDefaultValue(defaultV, type){
    if(defaultV){
        if(type.toUpperCase() == "TIMESTAMP" && defaultV == "CURRENT_TIMESTAMP"){
            return "DEFAULT CURRENT_TIMESTAMP ";
        }
        
        else if(type.toUpperCase() == "DATETIME" && defaultV == "CURRENT_TIMESTAMP")
            return "DEFAULT CURRENT_DATE ";

        else if(parseInt(defaultV) || defaultV == "0")
            return "DEFAULT " + defaultV +" "
        else
            return "DEFAULT '" + defaultV +"' "
    }
   
    else
        return " ";
}

function checkExtra(extra){
    let returnExtra = "";
    switch (extra) {
        case "auto_increment":
            returnExtra = hanaSQLParams.IDENTITY;
            break;
        default:
            break;
    }
    return returnExtra;
}

function hanaColType(type){
    // console.log(type);
    type = type.replace(mySQLParams.SMALLINT, hanaSQLParams.SMALLINT);
    type = type.replace(mySQLParams.TINYINTEGER, hanaSQLParams.TINYINT);
    type = type.replace(mySQLParams.BIGINTEGER, hanaSQLParams.BIGINT);
    type = type.replace(mySQLParams.INT, hanaSQLParams.INTEGER);
    type = type.replace(mySQLParams.AUTO_INCREMENT, hanaSQLParams.IDENTITY)
    type = type.replace(mySQLParams.TINYTEXT, hanaSQLParams.VARCHARTEN);
    type = type.replace(mySQLParams.LONGTEXT, hanaSQLParams.VARCHARMAX);
    type = type.replace(mySQLParams.MEDIUMTEXT, hanaSQLParams.VARCHARMEDIUM);
    type = type.replace(mySQLParams.UNASIGNED, hanaSQLParams.BLANK);
    type = type.replace(mySQLParams.CHARACTER_SET_LATIN1, hanaSQLParams.BLANK);
    type = type.replace(mySQLParams.LATIN1_BIN, hanaSQLParams.BLANK);
    type = type.replace(mySQLParams.COLLATE, hanaSQLParams.BLANK);
    type = type.replace(mySQLParams.LONGBLOB, hanaSQLParams.BLOB);
    type = type.replace(mySQLParams.DOUBLE, hanaSQLParams.DECIMAL);
    // console.log(type);
    return type.toUpperCase() + " ";
}

function checkNotNull(nullCheck){
    return (nullCheck.toUpperCase() == "NO") ? "NOT NULL " : ""
}

 async function showAllMysqlTableNames(next){
    let tables;
    try {
       // dbConn = await dbConnect();

        tables = await showTableNames();
       
    } catch (error) {
        console.log(error);
        fs.appendFileSync("./sql/create/ErrorLog_log",new Date()+  error +"\n"); 
      
        //dbDisconnect();
        //return next(error);
        // LOG ERROR
    }
    return next(null,tables);
}





async function insertDataInTables(selectedTableNames,next){
   
       //for (const tableName of config.tables) {
         for (const tableNameObj of selectedTableNames) {
         const done = await insertDataInSingleTable(tableNameObj.itemName);
        }
       await next(null,"done");
     }


  async  function insertDataInSingleTable(tableName){
  
         startTimeInMs=  Date.now();
         try {
            columns =  await showTableColumn(tableName);
            console.log("columns1:"+columns);
           data = await getResult(tableName);
           console.log("data1:"+data);
            insertQueries = await createInsertQuery(tableName,columns,data);
            console.log("insertQueries1:"+insertQueries);
            executeInsertQuery(tableName,insertQueries);
         
        } catch (error) {
           console.log("Error main:"+error);
           fs.appendFileSync("./sql/create/ErrorLog_log",new Date()+  error +"\n"); 
      
       }
      return "done";
     
}


function getResult(tableName){
   return new Promise((resolve,reject)=>{
       const selectQuery = "SELECT * FROM eclinic_kng."+ tableName.toUpperCase() +";";
         db_query.paramQuery(selectQuery,[], function (err, result) {
           if(err) return reject(err.sqlMessage);
            return resolve(result);
       })
   });
}
  function executeInsertQuery(tableName,insertQueries){
       let totalCount=0;
       let failCount=0;
         for (let i = 0; i < insertQueries.length; i++) {
               totalCount++;
               hanaCon.exec(insertQueries[i], function (err, affectedRows) {
                   if(err) {
                      failCount++;
                      fs.appendFileSync("./sql/data/"+tableName+".sql",new Date()+ "FailCount: "+failCount  +  err +"\n"+insertQueries+"\n"); 
                
                   }
           });
              
       }
      let totalTime=(Date.now()-startTimeInMs)/1000;
    fs.appendFileSync("./sql/data/"+tableName+".sql",new Date()+"TotalCount:"+totalCount+"\n"+"FailCount:"+failCount+"\n"+"TotalTime:"+totalTime+"\n");    
          
     
}

function createInsertQuery(tableName,colunms, data){
   let insertQueryArr=[];
   return new Promise((resolve,reject)=>{
       data.forEach((row)=>{
       let insertQuery = "INSERT INTO ECLINIC_KNG."+tableName.toUpperCase()+" VALUES " + loopOnColumns(row,colunms);
       insertQueryArr.push(insertQuery);
           
   });
   return resolve(insertQueryArr);
});
}

function loopOnColumns(row,colunms){
   let insertValues = "(";
   let index=-1;
   for(col in row){
       index++;
       if(colunms[index].Type.startsWith('varchar')) {
        insertValues = insertValues + "'" + row[col] + "',"
       }
       else {
            insertValues = insertValues + row[col] + "," 
           }
   }

   insertValues=insertValues.substring(0, insertValues.length-1);
   return insertValues + ");"
}
function createFile(path,content){
   fs.writeFile(path,content,(err)=>{
       if(err) console.log("err");

       console.log("***********************file saved at", path);
   });
}

function showTableColumn(table){
   // const query = "SHOW COLUMNS FROM eclinic_hmc." + table + ";";
   const query = "DESCRIBE " + table + ";";
   return new Promise((resolve,reject)=>{
       db_query.query(query,(err,definition)=>{
           console.log("err1"+err);
           if(err) return reject(err.sqlMessage);
           // console.log(definition);
           return resolve(definition);
       })
   });
}

 
exports.getMysqlConnection = getMysqlConnection;
exports.getHanaConnection = getHanaConnection;
exports.showAllMysqlTableNames = showAllMysqlTableNames;
exports.createtables = createtables;
exports.insertDataInTables = insertDataInTables;



